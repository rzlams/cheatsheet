<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>My cheatsheet</title>
    <style>
        * {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }

        table {
            width: 100%;
        }

        table,
        td,
        tr,
        th {
            border: 1px solid black;
            border-collapse: collapse;
            position: relative;
        }

        th {
            padding: .8em;
            text-transform: uppercase;
            background-color: darkblue;
            color: white;
        }

        tbody>tr:nth-child(odd) {
            background-color: white;
        }

        tbody>tr:nth-child(even) {
            background-color: lightblue;
        }

        td {
            padding: 1em;
            opacity: .6;
        }

        tbody td:hover {
            opacity: 1;
        }

        input {
            width: 25%;
            padding: .5em 0;
            margin-bottom: 1em;
        }

        tr>td:first-child {
            font-weight: bold;
            text-align: center;
            width: 10%;
        }

        tr>td:last-child {
            width: 35%;
        }

        img {
            width: 100%;
        }
    </style>
</head>

<body>
    <input type="search" id="inputCuenta" onkeyup="myFilterCuenta()" placeholder="Buscar por tecnologia">
    <input type="search" id="inputDetalle" onkeyup="myFilterDetalle()" placeholder="Buscar por sintaxis">

    <table>
        <thead>
            <tr>
                <th>Tecnologia</th>
                <th>Sintaxis</th>
                <th>Descripcion</th>
            </tr>
        </thead>
        <tbody id="cuentas">
                <tr>
                    <td>Git</td>
                    <td>git diff [--name-status][--stat][--numstat] branch1 branch2 -- [archivo.ext]</td>
                    <td>
                      Lista todas las diferencias entre ambas ramsa. Ademas con:<br/>
                      --name-status : lista los archivos que han cambiado entre ambas ramas.<br/>
                      --stat : muestra la diferencia a nivel binario.<br/>
                      --numstat : muestra en número base decimal las diferencias en líneas.<br/>
                      -- [archivo.ext] : muestra los cambios del archivo especificado entre ambas ramas.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git diff-tree --no-commit-id --name-only -r [codigo_SHA]</td>
                    <td>Lista los nombres de todos los archivos pertenecientes al commit especificado</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git help '[nombre_comando]'</td>
                    <td>Muestra toda la documentacion relacionada</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global user.name '[nombre_usuario]'</td>
                    <td>Configura el nombre del usuario</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global user.email '[correo_usuario]'</td>
                    <td>Configura el correo del usuario</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global color.ui true</td>
                    <td>Activa colores para los mensajes en la terminal</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global --list</td>
                    <td>Muestra un listado de las configuraciones que se tienen</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>.git/config</td>
                    <td>Ruta de la configuracion local de git</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global [unset] alias.[alias] '[comando_original]'</td>
                    <td>
                        Configura un alias o shortcut:<br />
                        [alias] : el alias o shortcut que se va a crear.<br />
                        [comando_original] : el comando con todos sus flag y demas.<br />
                        [unset] (opcional) : elimina el alias especificado. No se pone el comando original.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git config --global --get-regexp [reex]</td>
                    <td>
                        Busca todas las configuraciones que coincidan con la regex que se especifica.<br />
                        Por ej: si se usa 'alias' devuelve todos los alias configurados.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git init</td>
                    <td>
                        Comienza a monitorear los archivos de la carpeta en la que nos encontramos (la carpeta de
                        nuestro proyecto)
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>touch .gitignore</td>
                    <td>Crea el archivo gitignore</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git clone [url] [nombre_destino]</td>
                    <td>
                        <b>[url] - (Requerido):</b> URL del repositorio que deseas clonar.<br />
                        <b>[nombre_destino] - (Opcional):</b> Especifica el nombre que quieres para la carpeta en la que
                        se recibira la copia del repositorio. Por defecto el nombre de la carpeta es el mismo que en el
                        repositorio original.<br /><br />s

                        <b>Por ejemplo:</b><br />
                        git clone https://github.com/libgit2/libgit2 mylibgit<br /><br />

                        Crea un directorio llamado 'mylibgit', inicializa un directorio .git en su interior, descarga
                        toda la información de ese repositorio y saca una copia de trabajo de la última versión.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git status</td>
                    <td>Muestra el estado de cada archivo dentro del repositorio</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git add -A</td>
                    <td>Agrega todos los archivos al staging area</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git commit -m '[descripcion_commit]'</td>
                    <td>Hace commit de lo que esta en el staging area</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git commit --amend -m '[descripcion_commit]'</td>
                    <td>Corrige el mensaje del ultimo commit</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git log [nombre_branch] --online --graph --decorate --since='[criterio]' | cat</td>
                    <td>
                        Muestra los commit que se han hecho en el branch que te encuentras. Tambien pues:<br />
                        [nombre_branch] : especificar la branch de la cual quieres ver los commmit.<br />
                        --oneline : muestra cada commit en una linea.<br />
                        --graph : muestra las distintas branch desde la que proviene cada commit<br />
                        --decorate : muestra la branch en la que origino cada commit.<br />
                        --since : filtra los commit que muestra. Puede ser una hora, por ej: '6am' o una fecha
                        '1991-01-31'.<br />
                        | cat : imprime el resultado en la consola. No solo lo muestra en modo vista.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git log > [nombre_archivo.txt]</td>
                    <td>
                        Crea un archivo .txt en la carpeta raiz del repositorio con el resultado del git log
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git checkout [codigo_SHA o nombre_branch]</td>
                    <td>
                        Se mueve dependiendo de lo que se coloque en el area que estan los parentesis:
                        <br />
                        <b>1.- Codigo_SHA:</b> cambia al commit con el codigo especificado.<br />
                        <b>2.- Nombre_branch:</b> cambia al ultimo commit de la branch.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git reset [--soft --mixed --hard][codigo SHA]</td>
                    <td>
                        Descarta los commit de la branch posteriores al commit seleccionado, puede ser:<br />
                        <b>--soft</b> : borra los commit pero no toca el staging area ni el working area<br />
                        <b>--mixed</b> : borra los commit y el staging area pero no toca el working area. Es el default
                        en caso de que se omita este primer parametro.<br />
                        <b>--hard</b> : borra TODO, los commit, el staging area y el working area.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git revert --no-commit [codigo SHA] [HEAD~1]</td>
                    <td>
                        Revierte los commit seleccionados generando un nuevo commit con los cambios revertidos.<br />
                        En la practica hace un merge agregando las lineas que quitaste y viceversa.<br />
                        <b>[HEAD~1]:</b> toma un commit desde HEAD. Con el numero se puede especificar la cantidad de
                        commits que se desea retroceder desde HEAD.<br />
                        <b>--no-commit:</b> con este flag evita que haga el commit asi que deja los cambios en el staging.<br />
                        <b>--no-commit:</b>
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git branch [-a -D -m][nombre_branch]</td>
                    <td>
                        Sin ningun parametro, muestra las branch no ocultas que existen:<br />
                        <b>-a </b> : muestra todas las branch, incluidas las ocultas.<br />
                        <b>-D </b> : elimina la branch que se ponga en el ultimo parametro.<br />
                        <b>-m </b> : cambia el nombre de la branch. Luego de este parametro se pone el nombre actual de
                        la rama y el nuevo nombre.<br />
                        <b>nombre_branch </b> : sin los parametros anteriores crea una branch nueva.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git merge [nombre_branch]</td>
                    <td>
                        Absorbe los cambios del branch que se usa en el comando, sin eliminarla.<br />
                        Primero debes pararte en la branch que quieres que absorba los cambios.<br />
                        Para resolver un conflicto se debe ir al archivo, se modifica para que quede<br />
                        como lo queremos (git inserta comentarios donde hay conflictos) y luego hacemos commit.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git rebase [nombre_branch o codigo_SHA] --abort --interactive</td>
                    <td>
                        CAMBIA EL HASH DE LOS COMMIT DE LA BRANCH ACTUAL QUE NO ESTEN EN LA QUE RECIBE, POR ESTO:<br />
                        &nbsp; &nbsp; - NO HACER REBASE A CONTENIDO QUE SE HAYA PUSHEADO.<br />
                        &nbsp; &nbsp; - SEGUIR EL SIGUIENTE PROCEDIMIENTO SIEMPRE QUE SE PUEDA.<br />
                        Se recomienda hacer rebase primero parado en la branch feature (absorber los commit de master) y
                        luego hacer rebase en master antes de hacer push.<br />
                        Funciona igual que merge pero en lugar de solo absorber los cambios de la rama seleccionada, si
                        se hace parado en:<br />
                        - Un branch 'feature': actualiza la branch con los commit de master y pone los commit de la
                        branch actual sobre todos los demas.<br />
                        - Master: absorbe los commit necesarios en master para actualizarse, los pone como ultimos
                        commit y elimina la referencia a la branch de donde provienen.
                        --abort : interrumpe el proceso de rebase, a veces queda pendiente por resolucion si encuentra
                        un conflicto.<br />
                        --interactive : permite operar sobre los commit de la rama actual, la que recibe el rebase.
                        NOTAS:<br />
                        &nbsp; &nbsp; - Pueden haber conflictos al tocar los commit.<br />
                        &nbsp; &nbsp; - Las opciones que da el comando se le colocan delante a cada commit.<br />
                        &nbsp; &nbsp; - El orden de los commit en el rebase es como aparecen, de arriba hacia abajo.
                        Para hace squash el anterior es el que esta arriba.<br />

                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>gitn cherry-pick [codigo_SHA_commit mas viejo]^..[codigo_SHA_commit mas nuevo]</td>
                    <td>
                        Hace merge de los commit de otra branch pero los introduce en la rama actual con un nuevo commit
                        (nuevo SHA).<br />
                        Puede ser un solo commit (se usa solo el primer parametro) o un rango de commits.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git [codigo_SHA]</td>
                    <td>Crea un nuevo commit en el que revierte todos los cambios del commit seleccionado.</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git checkout -b [nombre_branch]</td>
                    <td>Crea una branch nueva y te para en ella de una vez</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git format-patch -1 [codigo_SHA] [branch_destino] -o patches</td>
                    <td>
                        Estando en la branch con los cambios que se quieren incluir en un parche, se selecciona:<br />
                        [branch_destino] : compara la branch actual con la branch especificada y genera un parche por
                        cada commit.<br />
                        -1 [codigo_SHA] : genera un parche con el commit especificado.<br />
                        -o patches : especifica la carpeta (path relativo) en la que git guarda los archivos de los
                        patch creados.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git am [path_del_patch]</td>
                    <td>
                        Se debe estar parado en la branch que se quieren aplicar los parches.<br />
                        Este comando crea un nuevo commit, es decir, cambia el hash del commit original.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git remote add origin [url_repositorio_remoto_en_github]</td>
                    <td>Vincula el repositorio remoto con el local</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git remote -v</td>
                    <td>Muestra los repositorios que estan conectados</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git remote remove origin</td>
                    <td>Elimina el vinculo entre los repositorios local y remoto</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>
                        git push origin [nombre_branch o codigo_SHA][-f]<br />
                        git push origin [codigo_SHA]:[nombre_de_branch]
                    </td>
                    <td>
                        Sube a github el branch que se ponga en el primer parametro.<br />
                        -f : El segundo parametro es opcional, fuerza a que se suba el branch seleccionado.<br />
                        La segunda opcion es para subir un solo commit. Sube el commit especificado y todos los
                        anteriores.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git tag -a [nombre_tag] -m '[descripcion_commit]' [codigo_SHA]</td>
                    <td>
                        <b>[nombre_tag] - (Requerido):</b> Agrega un tag, normalmente un numero de version u otro
                        distintivo.<br />
                        <b>'[descripcion_commit]' - (Opcional):</b> Agrega una descripcion (comentario) al tag.<br />
                        <b>[codigo_SHA] - (Opcional):</b> Asigna el tag a un commit.
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git push origin [nombre_tag]</td>
                    <td>Sube a github el tag seleccionado</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git push origin --tags</td>
                    <td>Sube todos los tags a github</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>
                        <b>git fetch origin</b><br />
                        Baja los cambios del repositorio remoto a la branch oculta (origin/master)
                        <br /><br />
                        Luego se puede:<br />
                        Hacer merge desde la branch que usaremos en el repositorio local.<br />
                        Hacer push para subir cambios al repositorio remoto.
                    </td>
                    <td>
                        WORKFLOW - PROYECTOS EN EQUIPO
                        <img class="imagen-descripcion" src="images/git-workflow-equipo.png"
                            alt="Branches de Worflow para proyectos en equipo" />
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>
                        Para colaborar en un proyecto de un tercero se debe hacer Fork en GitHub.
                        <br />
                        Esto clona el repositorio a nuestra cuenta. Esta copia en nuestra cuenta es la que vamos a poder
                        modificar.<br /><br />

                        Una vez en este punto tendremos dos branch ocultas:<br />
                        - Una para hacer fetch a la copia en nuestra cuenta (origin/master), tal cual como en el
                        workflow en equipo.<br />
                        - Una para hacer fetch (upstream/master) al proyecto original, para obtener una copia
                        actualizada.<br /><br />

                        Una vez hechos los cambios que se desean proponer se suben al repositorio propio (el clon) y
                        desde ahi se hace un Pull Request.<br /><br />

                        Por ultimo el dueño del proyecto puede, o no, hacer merge de los cambios propuestos.
                    </td>
                    <td>
                        WORKFLOW - PROYECTOS DE TERCEROS
                        <img class="imagen-descripcion" src="images/git-workflow-terceros.png"
                            alt="Branches de Worflow para proyectos de terceros" />
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>ssh-keygen</td>
                    <td>Genera la clave SSH (publica y privada)</td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git stash [save 'mensaje_descriptivo'] [--patch][list][apply][drop][show] [stash]</td>
                    <td>
                        Guarda los cambios del staging area en el 'stash' y los oculta del working tree.<br />
                        El stash esta disponible en todas las branch locales, asi que se puede aplicar<br />
                        cualquier stash a la branch en la que te encuentres.<br />
                        El ultimo stash guardado es el que tiene 'index' 0. Opciones:<br /><br />
                        save 'mensaje_descriptivo': el mensaje es opcional pero ayuda a identificar el stash cuando se
                        listan.<br />
                        --patch: abre el modo interactivo y te va preguntando que quieres guardar y que no (elige "y", "n" u otra opcion)<br />
                        pop : aplica el ultimo stash guardado y lo saca de la lista<br />
                        list : muestra los stash guardados.<br />
                        drop : borra el ultimo stash de la lista.<br />
                        show : muestra el detalle de los cambios del stash especificado con su identificador.<br />
                        apply : aplica el ultimo stash sin borrarlo o el stash especificado con su identificador.<br />
                    </td>
                </tr>
                <tr>
                    <td>Git</td>
                    <td>git diff stash@{0}^1 stash@{0} -- [archivo]</td>
                    <td>
                      Hacer el diff de cualquier elemento del stash contra el último commit del branch actual<br/>
                      Adicionalmente se puede especificar el archivo para el que se quiere el diff
                    </td>
                </tr>
        </tbody>
    </table>


    <script>

        function myFilterCuenta() {
            var tr, td, inputCuenta, filterCuenta,
                i, textValue;

            tr = document.getElementsByTagName("tr");
            inputCuenta = document.getElementById("inputCuenta");
            filterCuenta = inputCuenta.value.toUpperCase();

            for (i = 0; i < tr.length; i++) {
                td = tr[i].getElementsByTagName("td")[0];

                if (td) {
                    textValue = td.textContent;
                    if (textValue.toUpperCase().indexOf(filterCuenta) > -1) {
                        tr[i].style.display = "";
                    } else { tr[i].style.display = "none"; }
                }
            }
        }
        function myFilterDetalle() {
            var tr, td, inputDetalle, filterDetalle,
                i, textValue;

            tr = document.getElementsByTagName("tr");
            inputDetalle = document.getElementById("inputDetalle");
            filterDetalle = inputDetalle.value.toUpperCase();

            for (i = 0; i < tr.length; i++) {
                td = tr[i].getElementsByTagName("td")[1];

                if (td) {
                    textValue = td.textContent;
                    if (textValue.toUpperCase().indexOf(filterDetalle) > -1) {
                        tr[i].style.display = "";
                    } else { tr[i].style.display = "none"; }
                }
            }
        }

    </script>
</body>

</html>
